use crate::dom::tree::{NodeData, NodeRef};
use crate::layout::dimensions::{LogicalDimensions, PhysicalDimensions};
use crate::layout::{BoxComponent, DumpLayout, DumpLayoutFormat, LogicalDirection};
use crate::style::values::computed::length::{
    CSSPixelLength, LengthPercentage, LengthPercentageOrAuto,
};
use crate::style::values::computed::{ComputedValues, Direction, WritingMode};
use crate::style::values::used::ToPx;
use crate::Side;
use std::cell::Ref;
use std::io::Write;
use std::mem::discriminant;

/// Describes various charecteristics about a box, such as how it behaves in a flow layout or
///
/// Loosely maps to the "Generated box" column from the table in this section,
/// https://drafts.csswg.org/css-display/#the-display-properties, with the addition of other
/// scattered box types (like anonymous box types).
#[derive(Clone, Debug)]
// TODO: Rename to LayoutBox and fix the above doc comment.
pub enum LayoutBox {
    /// A box not associated with any element.
    /// https://drafts.csswg.org/css-display/#anonymous
    Anonymous(AnonymousBox),

    /// An example of an anonymous inline box is the root inline box generated by block containers
    /// who have inline content that needs a place to go.
    ///
    /// For more information about this box type, see: https://drafts.csswg.org/css-inline-3/#model
    ///
    /// An aside, quoting https://drafts.csswg.org/css-display/#block-container:
    ///   > Note, this root inline box concept effectively replaces the "anonymous inline element"
    ///     concept introduced in CSS2ยง9.2.2.1.
    AnonymousInline(AnonymousInlineBox),

    BlockLevel(BlockLevelBoxType),

    InlineLevel(InlineLevelBoxType),
}

/// https://drafts.csswg.org/css-display/#anonymous
#[derive(Clone, Debug)]
pub struct AnonymousBox {
    children: Vec<BoxType>,
    dimensions: LogicalDimensions,
    /// Reference to the closest non-anonymous node, which is what we will use to get styles.
    closest_node: NodeRef,
}

#[derive(Clone, Debug)]
pub struct AnonymousInlineBox {
    children: Vec<BoxType>,
    dimensions: LogicalDimensions,
    /// Reference to the closest non-anonymous node, which is what we will use to get styles.
    closest_node: NodeRef,
}

#[derive(Clone, Debug)]
pub struct BlockLevelBox {
    children: Vec<BoxType>,
    dimensions: LogicalDimensions,
    node: NodeRef,
}

#[derive(Clone, Debug)]
pub struct BlockBox {
    children: Vec<BoxType>,
    dimensions: LogicalDimensions,
    node: NodeRef,
}

#[derive(Clone, Debug)]
pub struct BlockLevelBlockContainer {
    children: Vec<BoxType>,
    dimensions: LogicalDimensions,
    node: NodeRef,
}

#[derive(Clone, Debug)]
pub enum BlockLevelBoxType {
    /// A box that is block-level when placed in flow layout.
    /// https://drafts.csswg.org/css-display/#block-level-box
    BlockLevel(BlockLevelBox),

    /// A block-level box that is also a block container (not all block containers are block-level
    /// boxes).
    /// https://drafts.csswg.org/css-display/#block-box
    BlockBox(BlockBox),

    /// Box that contains only block-level boxes participating in a block formatting context.
    /// https://drafts.csswg.org/css-display/#block-container
    BlockContainer(BlockLevelBlockContainer),

    // Eventually, other box types from the "Generated box" column from the table in this section
    // https://drafts.csswg.org/css-display/#the-display-properties will be added.
    // E.g., FlexContainer, GridContainer
}

#[derive(Clone, Debug)]
pub struct InlineLevelBlockContainer {
    children: Vec<BoxType>,
    dimensions: LogicalDimensions,
    node: NodeRef,
}

#[derive(Clone, Debug)]
pub struct InlineBox {
    children: Vec<BoxType>,
    dimensions: LogicalDimensions,
    node: NodeRef,
}

#[derive(Clone, Debug)]
pub struct InlineLevelBox {
    children: Vec<BoxType>,
    dimensions: LogicalDimensions,
    node: NodeRef,
}

#[derive(Clone, Debug)]
pub enum InlineLevelBoxType {
    /// Box that contains only inline-level boxes participating in a block formatting context.
    /// https://drafts.csswg.org/css-display/#block-container
    BlockContainer(InlineLevelBlockContainer),
    /// A non-replaced inline-level box whose inner display type is flow. The contents of an inline
    /// box participate in the same inline formatting context as the inline box itself.
    ///
    /// This is also known as an "inline-block".
    ///
    /// https://drafts.csswg.org/css-display/#inline-box
    InlineBox(InlineBox),

    /// A box that participates in inline layout.
    /// https://drafts.csswg.org/css-display/#inline-level
    InlineLevel(InlineLevelBox)

    // Eventually, other box types from the "Generated box" column from the table in this section
    // https://drafts.csswg.org/css-display/#the-display-properties will be added.
    // E.g., FlexContainer, GridContainer
}

#[derive(Clone, Debug)]
pub struct LayoutBoxOld {
    box_type: BoxType,
    children: Vec<LayoutBox>,
    dimensions: LogicalDimensions,
    direction: Direction,
    /// Reference to the closest non-anonymous node.  This distinction only matters for anonymous
    /// boxes, since anonymous boxes are by definition not associated with a node, but need access
    /// to a node to get computed values during layout.  If the box is a block, inline, or any other
    /// non-anonymous box, this field is simply the actual DOM node associated with this box.
    node: NodeRef,
    writing_mode: WritingMode,
}

impl LayoutBoxOld {
    /// Creates a new layout box.  The passed in node should be the DOM node associated with
    /// the box, assuming it is a non-anonymous box.  If creating an anonymous box, `node`
    /// should be the DOM node associated with the closest non-anonymous box.
    pub fn new(
        box_type: BoxType,
        node: NodeRef,
        direction: Direction,
        writing_mode: WritingMode,
    ) -> LayoutBox {
        LayoutBox {
            box_type,
            dimensions: LogicalDimensions::new(writing_mode, direction),
            direction,
            children: Vec::new(),
            node,
            writing_mode,
        }
    }

    pub fn physical_dimensions(&self) -> PhysicalDimensions {
        self.dimensions.physical()
    }

    pub fn children(&self) -> &[LayoutBox] {
        &self.children
    }

    /// Retrieve the computed values of the node associated with this layout box.
    pub fn computed_values(&self) -> Ref<ComputedValues> {
        self.node.computed_values()
    }

    /// Determines if this layout box is associated with the root DOM node (<html>).
    pub fn is_root(&self) -> bool {
        match self.node.parent() {
            None => false,
            Some(parent) => matches!(*parent.data(), NodeData::Document(_)),
        }
    }

    /// Directly adds `new_child` to this layout box's children.
    pub fn add_child(&mut self, new_child: LayoutBox) {
        self.children.push(new_child)
    }

    /// Adds the `new_child` to the proper inline-container of `self`.
    pub fn add_child_inline(&mut self, new_child: LayoutBox) {
        self.get_root_inline_box().children.push(new_child)
    }
}

/// Writes a textual representation of the layout tree starting with the `self` LayoutBox.  Built
/// to somewhat match WebKit's version of layout dumps, which look like:
///
/// RenderView at (0,0) size 1166x819 renderer->(0x3055f9250)
/// B-----L- --    HTML RenderBlock at (0,0) size 1166x6248.50 renderer->(0x3055f9700) node->(0x3055f9550)
/// B------- --      BODY RenderBody at (0,0) size 1166x6248.50 renderer->(0x3055f9830) node->(0x3055f9670)
/// B------- --        DIV RenderBlock at (0,0) size 1166x0 renderer->(0x306fcc900) node->(0x305a18480)
/// B------- --        DIV RenderBlock at (0,0) size 1166x0 renderer->(0x306fcca20) node->(0x305a18700)
/// B------- --        DIV RenderBlock at (260,0) size 906x6248.50 renderer->(0x306fccb40) node->(0x305a18800)
/// BX-O--LC --          NAV RenderFlexibleBox at (0,0) size 260x819 renderer->(0x30ddf2e20) node->(0x30dde41c0)
///
/// With the `verbose` flag, much more information is printed (such as all of the margin, border,
/// and padding values).
impl DumpLayout for LayoutBox {
    fn dump_layout<W: Write>(&self, _write_to: &mut W, _indent_spaces: usize, _verbose: bool) {
        // TODO: Fix
        // let node_name = match self.box_type {
        //     BoxType::Anonymous | BoxType::AnonymousInline => "".to_owned(),
        //     BoxType::Block | BoxType::Inline => self.node.data().dump_layout_format(),
        // };
        // let physical_dimensions = self.dimensions.physical();
        // let verbose_str = if verbose {
        //     format!(
        //         " (ml{} mr{} mb{} mt{} bl{} br{} bb{} bt{} pl{} pr{} pb{} pt{})",
        //         physical_dimensions.margin.left.dump_layout_format(),
        //         physical_dimensions.margin.right.dump_layout_format(),
        //         physical_dimensions.margin.bottom.dump_layout_format(),
        //         physical_dimensions.margin.top.dump_layout_format(),
        //         physical_dimensions.border.left.dump_layout_format(),
        //         physical_dimensions.border.right.dump_layout_format(),
        //         physical_dimensions.border.bottom.dump_layout_format(),
        //         physical_dimensions.border.top.dump_layout_format(),
        //         physical_dimensions.padding.left.dump_layout_format(),
        //         physical_dimensions.padding.right.dump_layout_format(),
        //         physical_dimensions.padding.bottom.dump_layout_format(),
        //         physical_dimensions.padding.top.dump_layout_format(),
        //     )
        // } else {
        //     "".to_owned()
        // };
        // writeln!(
        //     write_to,
        //     "{:indent_spaces$}{} {:?} LayoutBox at ({}, {}) size {}x{}{}",
        //     "",
        //     node_name,
        //     self.box_type,
        //     physical_dimensions.content.start_x.dump_layout_format(),
        //     physical_dimensions.content.start_y.dump_layout_format(),
        //     physical_dimensions.content.width.dump_layout_format(),
        //     physical_dimensions.content.height.dump_layout_format(),
        //     verbose_str,
        //     indent_spaces = indent_spaces,
        // )
        // .expect("error writing layout dump");
        //
        // self.children.iter().for_each(|child| {
        //     child.dump_layout(write_to, indent_spaces + 2, verbose);
        // })
    }
}

