// Useful links:
//  * https://www.w3.org/TR/css-display-3/#css-box
//  * https://www.w3.org/TR/2018/WD-css-box-3-20181218/#intro
pub mod dimensions;
pub mod flow;
pub mod formatting_context;
pub mod layout_box;
pub mod rect;
pub mod values;

use crate::dom::tree::{NodeData, NodeRef};
use crate::layout::dimensions::PhysicalDimensions;
use crate::layout::formatting_context::{FormattingContext, QualifiedFormattingContext};
use crate::layout::layout_box::{
    AnonymousBlockBox, AnonymousInlineBox, BlockContainer, InlineBox, LayoutBox, TextRun,
};
use crate::layout::rect::Rect;
use crate::style::values::computed::display::{
    DisplayBox, FullDisplay, InnerDisplay, OuterDisplay,
};
use crate::style::values::computed::length::CSSPixelLength;
use crate::style::values::computed::Display;
use crate::style::values::CSSFloat;
use std::io::Write;
use std::rc::Rc;

/// Takes a DOM node and builds the corresponding box tree of it and its children.  Returns
/// `None` if `node` is a `Display::None`.
///
/// In Kosmonaut, the terms "box tree" and "layout tree" are not the same in that the layout tree
/// represents the box tree post-layout (sizes and positions assigned). However, this distinction
/// isn't always held up, and sometimes "box tree" and "layout tree" are used interchangeably.
///
/// `parent_context` is the formatting context which the boxes generated by this node should join
/// (assuming the boxes generated by this node don't establish their own formatting context.)
///
/// If this is `None`, that means the boxes generated by the given `node` are expected to generate a
/// new formatting context.
pub fn build_box_tree(
    node: NodeRef,
    parent_context: Option<Rc<QualifiedFormattingContext>>,
) -> Option<LayoutBox> {
    match node.data() {
        // We don't want to create boxes for the document node nor the doctype nodes, so skip past
        // them to the root <html> element and start building the box tree there.
        //
        // Here's what the box tree would like if we didn't do this (which would be incorrect):
        //
        // DOCUMENT Inline LayoutBox at (0, 0) size 1920x184  --- Bad
        //   DOCTYPE Inline LayoutBox at (0, 0) size 1920x0   --- Bad
        //   HTML Block LayoutBox at (0, 0) size 1920x184
        //     BODY Block LayoutBox at (8, 8) size 1904x168
        //       ...
        NodeData::Document(_) => {
            return node
                .children()
                .find(|child| match child.data() {
                    NodeData::Element(data) => local_name!("html") == data.name.local,
                    _ => false,
                })
                .map(|html_node| build_box_tree(html_node, None))
                .flatten();
        }
        _ => {} // Not the document node — continue building the box tree normally.
    }

    let computed_values = &*node.computed_values();
    // TODO: We need to think about the validity of making strong-ref clones to nodes here (and elsewhere).
    // Will things get properly dropped?  Maybe LayoutBox should store a `Weak` ref?

    let mut layout_box = if let NodeData::Text(text) = node.data() {
        // https://drafts.csswg.org/css-display-3/#flow-layout
        // > If the [text] sequence contains no text, however, it does not generate a text run.
        let contents = text.clone().take().trim().to_owned();
        if contents.is_empty() {
            return None;
        }
        let pfc = parent_context.unwrap();
        assert!(pfc.is_inline_formatting_context());
        LayoutBox::TextRun(TextRun::new(node.clone(), pfc, contents))
    } else {
        // Per the "Generated box" column from the table in this section, decide what boxes to generate
        // from this DOM node.  https://drafts.csswg.org/css-display/#the-display-properties
        match computed_values.display {
            Display::Full(full_display) => {
                match (full_display.outer(), full_display.inner()) {
                    (OuterDisplay::Block, InnerDisplay::Flow) => {
                        // Per https://www.w3.org/TR/css-display-3/#block-container, join this new block
                        // container with our parent formatting context if it is a BFC.
                        let formatting_context = match parent_context.clone() {
                            Some(rc_qfc) => {
                                match *rc_qfc {
                                    QualifiedFormattingContext::Independent(
                                        FormattingContext::Block,
                                    )
                                    | QualifiedFormattingContext::Dependent(
                                        FormattingContext::Block,
                                    ) => parent_context.unwrap(),
                                    // Parent formatting context is not a BFC, create a new one instead.
                                    _ => Rc::new(QualifiedFormattingContext::Independent(
                                        FormattingContext::Block,
                                    )),
                                }
                            }
                            // There is no parent formatting context -- create a new BFC.
                            _ => Rc::new(QualifiedFormattingContext::Independent(
                                FormattingContext::Block,
                            )),
                        };

                        LayoutBox::BlockContainer(BlockContainer::new(
                            node.clone(),
                            formatting_context,
                        ))
                    }
                    (OuterDisplay::Block, InnerDisplay::FlowRoot) => {
                        LayoutBox::BlockContainer(BlockContainer::new(
                            node.clone(),
                            Rc::new(QualifiedFormattingContext::Independent(
                                FormattingContext::Block,
                            )),
                        ))
                    }
                    (OuterDisplay::Inline, InnerDisplay::Flow) => {
                        let formatting_context = match parent_context.clone() {
                            Some(rc_qfc) => {
                                match *rc_qfc {
                                    QualifiedFormattingContext::Independent(FormattingContext::Inline) |
                                    QualifiedFormattingContext::Dependent(FormattingContext::Inline) => {
                                        parent_context.unwrap()
                                    }
                                    _ => panic!("when trying to add inline box, parent formatting context was present but it wasn't an inline formatting context")
                                }
                            }
                            _ => {
                                panic!("there was no parent formatting context to add inline box to")
                            }
                        };
                        LayoutBox::InlineBox(InlineBox::new(node.clone(), formatting_context))
                    }
                    (OuterDisplay::Inline, InnerDisplay::FlowRoot) => unimplemented!(),
                }
            }
            Display::Box(DisplayBox::None) => return None,
        }
    };

    for child in node.children() {
        if let NodeData::Text(text) = child.data() {
            // https://drafts.csswg.org/css-display-3/#flow-layout
            // > If the [text] sequence contains no text, however, it does not generate a text run.
            let contents = text.clone().take().trim().to_owned();
            if contents.is_empty() {
                continue;
            }

            let inline_container = get_or_create_inline_container(&mut layout_box, child.clone());
            inline_container.add_child(LayoutBox::TextRun(TextRun::new(
                child.clone(),
                inline_container.formatting_context(),
                text.clone().take().trim().to_owned(),
            )));
            continue;
        }

        let child_computed_values = &*child.computed_values();
        match child_computed_values.display {
            Display::Full(full_display) => {
                match (full_display.outer(), full_display.inner()) {
                    (OuterDisplay::Block, InnerDisplay::Flow)
                    | (OuterDisplay::Block, InnerDisplay::FlowRoot) => {
                        if let Some(child_box) =
                            build_box_tree(child.clone(), Some(layout_box.formatting_context()))
                        {
                            // TODO: We don't handle the case where a block-flow child box is added to an inline box.
                            // This current behavior is wrong — we should be checking if `node` is an `Display::Inline` and
                            // doing something different here.  To fix, see: https://www.w3.org/TR/CSS2/visuren.html#box-gen
                            // Namely, the paragraph that begins with "When an inline box contains an in-flow block-level box"
                            // This concept _might_ be called "fragmenting".
                            layout_box.add_child(child_box)
                        }
                    }
                    (OuterDisplay::Inline, InnerDisplay::Flow) => {
                        let inline_container =
                            get_or_create_inline_container(&mut layout_box, child.clone());
                        if let Some(child_box) = build_box_tree(
                            child.clone(),
                            Some(inline_container.formatting_context()),
                        ) {
                            inline_container.add_child(child_box)
                        }
                    }
                    (OuterDisplay::Inline, InnerDisplay::FlowRoot) => unimplemented!(),
                }
            }
            Display::Box(DisplayBox::None) => {}
        }
    }
    Some(layout_box)
}

fn get_or_create_inline_container(
    layout_box: &mut LayoutBox,
    node_for_container: NodeRef,
) -> &mut LayoutBox {
    if layout_box.get_mut_inline_container().is_none() {
        layout_box.add_child(create_inline_container(node_for_container.clone()));
    }
    // TODO: There must be another way to get the anonymous inline box we just added.
    // This could cause poor runtime performance for boxes with a lot of children, but works for now.
    // Maybe we'd need to use RefCell in order to get this kind of interior mutability?
    layout_box.get_mut_inline_container().unwrap()
}

fn create_inline_container(node: NodeRef) -> LayoutBox {
    // Create a new IFC for this inline content.
    let mut anonymous_block_box = AnonymousBlockBox::new(
        node.clone(),
        Rc::new(QualifiedFormattingContext::Independent(
            FormattingContext::Inline,
        )),
    );
    anonymous_block_box.add_child(LayoutBox::create_root_inline_box(
        node.clone(),
        anonymous_block_box.formatting_context(),
    ));
    anonymous_block_box.into()
}

/// Given a `window` and what probably should be the root of a `box_tree`, perform a layout
/// with the dimensions of the `window`.
pub fn global_layout(
    box_tree: &mut LayoutBox,
    inner_window_width: f32,
    inner_window_height: f32,
    scale_factor: f32,
) {
    // box_tree.layout(
    //     PhysicalDimensions {
    //         content: Rect {
    //             start_x: 0.0,
    //             start_y: 0.0,
    //             width: CSSPixelLength::new(inner_window_width),
    //             height: CSSPixelLength::new(inner_window_height),
    //         },
    //         padding: Default::default(),
    //         border: Default::default(),
    //         margin: Default::default(),
    //     },
    //     scale_factor,
    // );
}

/// https://drafts.csswg.org/css-writing-modes-4/#logical-directions
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum LogicalDirection {
    BlockStart,
    BlockEnd,
    InlineStart,
    InlineEnd,
}

#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum BoxComponent {
    Border,
    Margin,
    Padding,
}

/// Trait describing behavior necessary for dumping the layout tree, used in the `dump-layout`
/// tests and debugging.  Should be implemented by "container"-style entities, such as members
/// of the layout tree, formatting individual struct members via the `DumpLayoutFormat` trait.
pub trait DumpLayout {
    fn dump_layout<W: Write>(&self, write_to: &mut W, indent_spaces: usize, verbose: bool);
}

/// Trait describing behavior necessary for formatting ones data in preparation for a layout tree
/// dump.
pub trait DumpLayoutFormat {
    fn dump_layout_format(&self) -> String;
}

impl DumpLayoutFormat for CSSFloat {
    fn dump_layout_format(&self) -> String {
        let px = format!("{:.2}", self);
        let mut px_trimmed = px.trim_end_matches('0');
        px_trimmed = px_trimmed.trim_end_matches('.');
        px_trimmed.to_owned()
    }
}

impl DumpLayoutFormat for CSSPixelLength {
    fn dump_layout_format(&self) -> String {
        self.px().dump_layout_format()
    }
}

impl DumpLayoutFormat for NodeData {
    fn dump_layout_format(&self) -> String {
        match self {
            NodeData::Comment(_) => "COMMENT".to_owned(),
            NodeData::Document(_) => "DOCUMENT".to_owned(),
            NodeData::Doctype(_) => "DOCTYPE".to_owned(),
            NodeData::DocumentFragment => "DOCUMENT_FRAGMENT".to_owned(),
            NodeData::Element(element_data) => element_data.name.local.to_uppercase(),
            NodeData::Text(text) => format!("TEXT \"{}\"", text.clone().take().trim()),
            NodeData::ProcessingInstruction(_) => "PROCESSING_INSTRUCTION".to_owned(),
        }
    }
}
