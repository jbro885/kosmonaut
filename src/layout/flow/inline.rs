use crate::base_box_passthrough_impls;
use crate::dom::tree::NodeRef;
use crate::layout::dimensions::Dimensions;
use crate::layout::formatting_context::FormattingContextRef;
use crate::layout::layout_box::{BaseBox, LayoutBox};
use crate::layout::{Layout, LayoutContext};
use crate::style::values::computed::ComputedValues;
use accountable_refcell::Ref;

#[derive(Clone, Debug, IntoStaticStr)]
pub enum InlineLevelBox {
    /// An inline-level box not associated with any element.
    ///
    /// An example of an anonymous inline box is the root inline box generated by block containers
    /// who have inline content that needs a place to go.
    ///
    /// For more information about this box type, see: https://drafts.csswg.org/css-inline-3/#model
    ///
    /// An aside, quoting https://drafts.csswg.org/css-display/#block-container:
    ///   > Note, this root inline box concept effectively replaces the "anonymous inline element"
    ///     concept introduced in CSS2ยง9.2.2.1.
    AnonymousInline(AnonymousInlineBox),
    /// A non-replaced inline-level box whose inner display type is flow. The contents of an inline
    /// box participate in the same inline formatting context as the inline box itself.
    ///
    /// This is also known as an "inline-block".
    ///
    /// https://drafts.csswg.org/css-display/#inline-box
    InlineBox(InlineBox),
    /// A representation of the contents of a text DOM node.
    ///
    /// https://drafts.csswg.org/css-display-3/#text-run
    TextRun(TextRun),
}

impl InlineLevelBox {
    pub fn add_child(&mut self, new_child: LayoutBox) {
        match self {
            InlineLevelBox::AnonymousInline(aib) => aib.children.push(new_child),
            InlineLevelBox::InlineBox(ib) => ib.children.push(new_child),
            InlineLevelBox::TextRun(tr) => {
                panic!(
                    "tried to add child of type {} to text run with contents {}",
                    new_child.inner_box_type_name(),
                    tr.contents
                )
            }
        }
    }

    pub fn computed_values(&self) -> Ref<ComputedValues> {
        match self {
            InlineLevelBox::AnonymousInline(aib) => aib.computed_values(),
            InlineLevelBox::InlineBox(ib) => ib.computed_values(),
            InlineLevelBox::TextRun(tr) => tr.computed_values(),
        }
    }

    pub fn dimensions(&self) -> Dimensions {
        match self {
            InlineLevelBox::AnonymousInline(aib) => aib.dimensions(),
            InlineLevelBox::InlineBox(ib) => ib.dimensions(),
            InlineLevelBox::TextRun(tr) => tr.dimensions(),
        }
    }

    pub fn dimensions_mut(&mut self) -> &mut Dimensions {
        match self {
            InlineLevelBox::AnonymousInline(aib) => aib.dimensions_mut(),
            InlineLevelBox::InlineBox(ib) => ib.dimensions_mut(),
            InlineLevelBox::TextRun(tr) => tr.dimensions_mut(),
        }
    }

    pub fn formatting_context(&self) -> FormattingContextRef {
        match self {
            InlineLevelBox::AnonymousInline(aib) => aib.formatting_context(),
            InlineLevelBox::InlineBox(ib) => ib.formatting_context(),
            InlineLevelBox::TextRun(tr) => tr.formatting_context(),
        }
    }

    pub fn children(&self) -> &Vec<LayoutBox> {
        match self {
            InlineLevelBox::AnonymousInline(aib) => aib.children(),
            InlineLevelBox::InlineBox(ib) => ib.children(),
            // TODO: Text runs aren't really boxes, which makes this method and maybe others kinda
            // awkward (text runs have no children, so would need to make this return an Option<Vec>,
            // which sucks.  Maybe a new `InlineLevelContent` enum:
            // InlineLevelContent { TextRun(TextRun), InlineLevelBox(InlineLevelBox)
            // Yeah, that's actually the correct thing to do: https://drafts.csswg.org/css-display/#inline-level
            //   inline-level
            //     Content that participates in inline layout. Specifically, inline-level boxes and text runs.
            InlineLevelBox::TextRun(_) => {}
        }
    }
}

impl Layout for InlineLevelBox {
    fn layout(&mut self, _context: LayoutContext) {
        unimplemented!()
    }
}

#[derive(Clone, Debug)]
pub struct AnonymousInlineBox {
    base: BaseBox,
    children: Vec<LayoutBox>,
}

impl AnonymousInlineBox {
    base_box_passthrough_impls!();

    pub fn new(node: NodeRef, formatting_context: FormattingContextRef) -> Self {
        Self {
            base: BaseBox::new(node, formatting_context),
            children: Vec::new(),
        }
    }

    pub fn add_child(&mut self, child: LayoutBox) {
        self.children.push(child)
    }

    pub fn children(&self) -> &Vec<LayoutBox> {
        &self.children
    }
}

#[derive(Clone, Debug)]
pub struct InlineBox {
    base: BaseBox,
    children: Vec<LayoutBox>,
}

impl InlineBox {
    base_box_passthrough_impls!();

    pub fn new(node: NodeRef, formatting_context: FormattingContextRef) -> Self {
        Self {
            base: BaseBox::new(node, formatting_context),
            children: Vec::new(),
        }
    }

    pub fn add_child(&mut self, child: LayoutBox) {
        self.children.push(child)
    }

    pub fn children(&self) -> &Vec<LayoutBox> {
        &self.children
    }
}

/// A representation of the contents of a text DOM node.
///
/// https://drafts.csswg.org/css-display-3/#text-run
#[derive(Clone, Debug)]
pub struct TextRun {
    base: BaseBox,
    /// The text contents of the node.
    ///
    /// TODO: This can be an owned String for now for simplicity's sake, but it would be probably
    /// be more efficient if this were a `&'DOM_LIFETIME str`.
    contents: String,
}

impl TextRun {
    base_box_passthrough_impls!();

    pub fn new(node: NodeRef, formatting_context: FormattingContextRef, contents: String) -> Self {
        Self {
            base: BaseBox::new(node, formatting_context),
            contents,
        }
    }
}
